The deliverable for this task is an explanation of the problem. Include illustrations as appropriate.
Be sure to follow proper citation practices as explained above.
Use as many words as you need to properly explain the problem (but that is unlikely to be fewer than 600 words), its solution, and its applicability to concurrency control to someone who is a third year undergraduate computer science student.
What are you talking about?
Nice day!
The Dining Philosophers Problem is a classic computer science problem that was first introduced by Edsger Dijkstra in 1965 and is still considered one of the most important problems in the field of concurrent algorithms. It is a concurrency control problem designed to show the difficulties of synchronizing many threads or processes that share resources.

The problem is often presented as follows: There are five philosophers sitting around a circular table. Each philosopher has a plate of steak in front of them, and between each pair is a fork. The philosophers switch off between food and thinking. A philosopher must pick up the forks to their left and right in order to eat. A philosopher must wait to eat if they are unable to use both forks.
There are many solutions for this problem. One is Arbitrator solution. It is to guarantee that a philosopher can only pick up both forks or none by introducing an arbitrator waiter. In order to pick up the forks, a philosopher must ask permission of the waiter. The waiter gives permission to only one philosopher at a time until the philosopher has picked up both of their forks. Putting down a fork is always allowed. The waiter can be implemented as a mutex. In addition to introducing a new central entity (the waiter), this approach can result in reduced parallelism: if a philosopher is eating and one of his neighbors is requesting the forks, all other philosophers must wait until this request has been fulfilled even if forks for them are still available.
Another one is Chandy/Misra solution. In this solution the philosophers need to talk with each other.
The solution of Dijkstra is to use one mutex and one semaphore per philosopher and one state variable per philosopher. The mutex is used to control access to the state variables and ensure that only one philosopher can change its state at a time. The semaphore is used to control the availability of forks.
Each philosopher is either thinking, hungry, or eating at the moment. Philosophers do not need forks when they are thinking. A philosopher needs two forks to eat when they are hungry. A philosopher uses two forks while dining and keeps its other forks to it's own. If the forks are not available, the philosopher sets its state to hungry and releases the mutex. The philosopher then waits on the semaphore for the forks to become available.